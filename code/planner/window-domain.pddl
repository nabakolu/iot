(define (domain awp)
(:requirements :strips :typing :numeric-fluents :preferences)
(:types 
    actuator sensors - object
    window blind heater - actuator
    noise wind rain light co2 - sensors
)

(:predicates 
            ; actuator states
            (open ?w - actuator)
            (closed ?w - actuator)
            ; windows
            (action_available ?w - window);prevent multiple window actions      
            (not_action_available ?w - window) ;prevent multiple window actions
            ; heater
            (heater_action_available ?h - heater)   ;prevent multiple heater actions
            (heater_off ?h - heater)
            (heater_on ?h - heater)
            ;blinds
            (blinding ?w - blind) ;blinding light at blind
            (not_blinding ?w - blind) ;avoid negative preconditions
            (not_blinding_initial ?w - blind)

)

(:functions
    ;ambient noise
    (ambientnoise ?w - window)
    ;wind
    (wind ?w - window)
    ;rain
    (rain ?w - window)
    ;co2 status
    (co2)
    ;heater target range
    (min_temp ?h - heater)
    (curr_temp ?h - heater)
    (temperatureDiffMinimum ?h - heater)
    (temperatureDiffOutside ?h - heater)
    ;checks if window is open
    (any_window_open)
    ;insentive earned by opening blinds
    (blindsmetric)
    ;for metric maximize
    (co2metric)
    ;value generated by using heaters
    (heaterweight)
    
)

(:action openwindow
:parameters (?window - window)
:precondition (and
                (action_available ?window) ;only allow action if window was not operated before
)
:effect  (and 
                (open ?window)
                (not(closed ?window))
                (not (action_available ?window))
                (not_action_available ?window)
                (assign (any_window_open) 1)
            ;update co2 reward
            (assign
                (co2metric)
                (+ co2metric (- (co2) (+ (ambientnoise ?window) (+ (wind ?window) (rain ?window))))))
        ))

(:action turn_heater_on
    :parameters (?heater - heater)
    :precondition (and
                        (heater_action_available ?heater) ;only allow action if heater has not taken action before
                        (< (curr_temp ?heater) (min_temp ?heater))
                        ;only allow heater action after all windows where operated
                        ;this is used since the reward for the heater depends on if windows are open or not
                        (forall (?w - window)
                            (not_action_available ?w)
                        )
    )
        :effect (and (not (heater_off ?heater))
            (heater_on ?heater)
            (not (heater_action_available ?heater))
            ;update heater reward
            (assign (heaterweight) (+ (heaterweight) (- (- (min_temp ?heater) (curr_temp ?heater)) (* (any_window_open) (temperatureDiffOutside ?heater)))))
    )
)

(:action turn_heater_off
    :parameters (?heater - heater)
    :precondition (and
                        (heater_action_available ?heater)   ;only allow action if heater has not taken action before
                        ;only allow heater action after all windows where operated
                        ;this is used since the reward for the heater depends on if windows are open or not
                        (forall (?w - window)
                            (not_action_available ?w)
                        )
                        
    )
    :effect (and (not (heater_on ?heater))
                (heater_off ?heater)
                (not (heater_action_available ?heater))
                ;update heater reward
                (increase (heaterweight) 0.1)
    )
)


(:action closewindow
:parameters (?window - window)
:precondition (and 
                    (action_available ?window)) ;only allow action if window was not operated before
:effect  (and   (closed ?window)
                (not(open ?window))
                ;update co2 reward
                (increase (co2metric) 0.1)
                ;set availability of actions for this window
                (not (action_available ?window))
                (not_action_available ?window)
))

(:action openblinds
:parameters (?blind - blind)
:precondition (and (closed ?blind) ;only allow if blinds to open if currently closed
                    (not_blinding_initial ?blind)   ;if light is not blinding at blinds dont open
)
:effect  (and   (open ?blind) ;set current status to open
                (not (closed ?blind))
                ;reward for opening blind
                (increase (blindsmetric) 1)
))

(:action closeblinds
:parameters (?blind - blind)
:precondition (and (blinding ?blind)    ;only allow blinds to close if they have blinding light
                    (open ?blind) ;only allow blinds to close if currently open
)
:effect  (and   (closed ?blind) ;set current status to closed
                (not (open ?blind)) 
                ;remove blinding status, since blinds are now closed
                (not(blinding ?blind))
                (not_blinding ?blind)
))

)


